library(shiny)
library(dplyr)
library(DT)
library(ggplot2)
library(scales)
library(tidyverse)
library(readr)
library(plotly)
library(MASS)  
library(purrr) 

# Load and prepare data
Endicott2026 <- read_csv("https://raw.githubusercontent.com/bgillis817/EndicottDashboard/refs/heads/main/ECRapsodo.csv")

# Print column names to debug
print("Column names in data:")
print(names(Endicott2026))

# Clean column names - remove special characters and spaces
names(Endicott2026) <- gsub("\\s+", "_", names(Endicott2026))
names(Endicott2026) <- gsub("[()]", "", names(Endicott2026))

# Check if Pitcher column exists, if not, look for alternatives
if(!"Pitcher" %in% names(Endicott2026)) {
  pitcher_col <- grep("pitcher|name", names(Endicott2026), ignore.case = TRUE, value = TRUE)[1]
  if(!is.na(pitcher_col)) {
    Endicott2026 <- Endicott2026 %>% rename(Pitcher = !!pitcher_col)
  } else {
    stop("Cannot find Pitcher column in data")
  }
}

Endicott2026 <- Endicott2026 %>%
  rename_with(~case_when(
    . == "Release_Height" | grepl("release.*height", ., ignore.case = TRUE) ~ "ReleaseHeight",
    . == "Release_Side" | grepl("release.*side", ., ignore.case = TRUE) ~ "ReleaseSide",
    . == "Total_Spin" | grepl("total.*spin", ., ignore.case = TRUE) ~ "TotalSpin",
    . == "VB_spin" | grepl("vb.*spin", ., ignore.case = TRUE) ~ "VB_spin",
    . == "HB_trajectory" | grepl("hb.*traj", ., ignore.case = TRUE) ~ "HB_trajectory",
    . == "Strike_Zone_Height" | grepl("strike.*zone.*height", ., ignore.case = TRUE) ~ "StrikeZoneHeight",
    . == "Strike_Zone_Side" | grepl("strike.*zone.*side", ., ignore.case = TRUE) ~ "StrikeZoneSide",
    . == "Release_Extension_ft" | grepl("release.*ext", ., ignore.case = TRUE) ~ "ReleaseExtension",
    . == "Pitch_Type" | grepl("pitch.*type", ., ignore.case = TRUE) ~ "PitchType",
    . == "Is_Strike" | . == "Is_strike" ~ "IsStrike",
    TRUE ~ .
  )) %>%
  mutate(
    ReleaseHeight = as.numeric(ReleaseHeight),
    ReleaseSide = as.numeric(ReleaseSide),
    Velocity = as.numeric(Velocity),
    TotalSpin = as.numeric(TotalSpin),
    VB_spin = as.numeric(VB_spin),
    HB_trajectory = as.numeric(HB_trajectory),
    StrikeZoneHeight = as.numeric(StrikeZoneHeight),
    StrikeZoneSide = as.numeric(StrikeZoneSide),
    ReleaseExtension = as.numeric(ReleaseExtension),
    No = as.numeric(No),
    Date = as.Date(Date, format = "%m/%d/%Y"),
    arm_angle = ifelse(
      !is.na(ReleaseHeight) & !is.na(ReleaseSide) & !is.na(Height) & ReleaseSide != 0,
      atan2(ReleaseHeight - (Height * 0.776), abs(ReleaseSide)) * (180 / pi),
      NA
    ),
    PlateLocSide = StrikeZoneSide / 12,
    PlateLocHeight = StrikeZoneHeight / 12,
    PitchType = case_when(
      PitchType == "Fastball" ~ "4-Seam",
      PitchType == "TwoSeamFastball" ~ "2-Seam",
      TRUE ~ PitchType
    )
  ) %>%
  arrange(Pitcher, Date, No) %>%
  group_by(Pitcher) %>%
  mutate(OverallPitchCount = row_number()) %>%
  ungroup()


# PITCH SEQUENCING

print("Columns available for pitch sequencing:")
print(names(Endicott2026))
print(paste("IsStrike column exists:", "IsStrike" %in% names(Endicott2026)))

# Create pitch sequences with lag
pitch_sequences <- Endicott2026 %>%
  arrange(Pitcher, Date, No) %>%
  group_by(Pitcher, Date) %>%
  mutate(
    prev_pitch_type = lag(PitchType),
    prev_is_strike = lag(IsStrike),
    prev_plate_loc_side = lag(PlateLocSide),
    prev_plate_loc_height = lag(PlateLocHeight)
  ) %>%
  ungroup() %>%
  filter(!is.na(prev_pitch_type))

# Debug: Check if pitch_sequences has data
print(paste("Pitch sequences created:", nrow(pitch_sequences), "rows"))

# Calculate strike rates by pitch pair
pitch_pair_matrix <- pitch_sequences %>%
  group_by(Pitcher, prev_pitch_type, PitchType) %>%
  summarise(
    n_pairs = n(),
    first_strike_rate = mean(prev_is_strike == "Y", na.rm = TRUE),
    second_strike_rate = mean(IsStrike == "Y", na.rm = TRUE),
    both_strike_rate = mean(prev_is_strike == "Y" & IsStrike == "Y", na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  mutate(
    strike_rate_diff = second_strike_rate - first_strike_rate,
    avg_strike_rate = (first_strike_rate + second_strike_rate) / 2
  )

# Debug: Check if pitch_pair_matrix has data
print(paste("Pitch pair matrix created:", nrow(pitch_pair_matrix), "rows"))

pitcher_names <- sort(unique(Endicott2026$Pitcher))

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .logo-container {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1000;
      }
      .logo-container img {
        height: 60px;
        width: auto;
      }
      .title-panel {
        position: relative;
        padding-left: 80px;
      }
      .matrix-cell {
        cursor: pointer;
        transition: opacity 0.2s;
      }
      .matrix-cell:hover {
        opacity: 0.8;
      }
    "))
  ),
  
  div(class = "logo-container",
      img(src = "https://raw.githubusercontent.com/bgillis817/EndicottDashboard/refs/heads/main/logo.jpg", 
          alt = "Endicott Logo")
  ),
  
  div(class = "title-panel",
      titlePanel("Endicott Pitching Dashboard")
  ),
  br(),
  
  sidebarLayout(
    sidebarPanel(
      h4(textOutput("pitcherInfo")),
      br(),
      selectInput("pitcher", "Select Pitcher", 
                  choices = pitcher_names,
                  selected = pitcher_names[1]),
      uiOutput("pitchRangeUI"),
      uiOutput("pitchTypeUI")
    ),
    
    mainPanel(
      tabsetPanel(
        tabPanel("Metrics/Summary", 
                 br(), 
                 dataTableOutput("pitcher_summary_table"),
                 br(),
                 plotlyOutput("pitch_movement_plot", height = "500px"),
                 plotlyOutput("pitch_release_plot", height = "450px")),
        tabPanel("Heat Maps", 
                 br(), 
                 plotOutput("plot1")),
        tabPanel("Arm Angle", 
                 br(), 
                 plotlyOutput("arm_angle_plot", height = "500px"),
                 br(),
                 p(style = "text-align: center; color: gray; font-size: 12px;", 
                   "Perspective from behind the pitcher's head")),
        
        # ===== PITCH SEQUENCING TAB =====
        tabPanel("Pitch Sequences",
                 br(),
                 fluidRow(
                   column(12,
                          h3(textOutput("sequence_title"), style = "text-align: center; font-weight: bold;"),
                          h5("Strike rate effectiveness by back-to-back pitch sequence", 
                             style = "text-align: center; color: gray;")
                   )
                 ),
                 br(),
                 fluidRow(
                   column(7,
                          plotOutput("sequence_matrix", height = "550px", click = "matrix_click")
                   ),
                   column(5,
                          h5("Pitch Location Heatmaps", 
                             style = "text-align: center; font-weight: bold; margin-bottom: 20px;"),
                          fluidRow(
                            column(6,
                                   h6(textOutput("hover_first_pitch_label"), 
                                      style = "text-align: center; font-weight: bold; color: #333;"),
                                   plotOutput("hover_first_pitch_location", height = "280px")
                            ),
                            column(6,
                                   h6(textOutput("hover_second_pitch_label"), 
                                      style = "text-align: center; font-weight: bold; color: #333;"),
                                   plotOutput("hover_second_pitch_location", height = "280px")
                            )
                          ),
                          br(),
                          wellPanel(
                            style = "background-color: #f8f9fa; padding: 15px;",
                            h6("Click on any cell to see pitch locations", 
                               style = "text-align: center; margin-bottom: 10px; color: #666;"),
                            htmlOutput("hover_stats")
                          )
                   )
                 )
        ),
        
        tabPanel("Locations", 
                 br(), 
                 plotOutput("pitch_location_plot1")),
        tabPanel("Velocity/Spin", 
                 br(), 
                 plotOutput("lineplot1", height = "400px"),
                 br(),
                 plotOutput("lineplot2", height = "400px"))
      )
    )
  )
)

server <- function(input, output, session) {
  
  output$pitcherInfo <- renderText({
    req(input$pitcher)
    if(input$pitcher == "") return("Please select a pitcher")
    
    pitcher_data <- Endicott2026 %>% filter(Pitcher == input$pitcher)
    total_pitches <- max(pitcher_data$OverallPitchCount, na.rm = TRUE)
    total_sessions <- n_distinct(pitcher_data$Date)
    paste0("Total: ", total_pitches, " pitches across ", total_sessions, " outings")
  })
  
  output$pitchTypeUI <- renderUI({
    req(input$pitcher)
    if(input$pitcher == "") return(NULL)
    
    pitcher_data <- Endicott2026 %>% filter(Pitcher == input$pitcher)
    pitch_types <- sort(unique(pitcher_data$PitchType))
    
    selectInput("pitchType", "Select Pitch Type", 
                choices = c("All", pitch_types))
  })
  
  output$pitchRangeUI <- renderUI({
    req(input$pitcher)
    if(input$pitcher == "") return(NULL)
    
    pitcher_data <- Endicott2026 %>% filter(Pitcher == input$pitcher)
    max_pitch <- max(pitcher_data$OverallPitchCount, na.rm = TRUE)
    
    pitcher_dates <- sort(unique(pitcher_data$Date))
    date_choices <- setNames(as.character(pitcher_dates), 
                             format(pitcher_dates, "%m/%d/%Y"))
    
    tagList(
      checkboxGroupInput("dateFilter", "Select Session(s) to Include:", 
                         choices = date_choices,
                         selected = as.character(pitcher_dates)),
      
      actionButton("selectAllDates", "Select All", 
                   style = "margin-right: 5px; margin-bottom: 10px;"),
      actionButton("selectNoDates", "Clear All", 
                   style = "margin-bottom: 10px;"),
      br(),
      
      numericInput("pitchRangeMin", "Minimum Pitch Number", 
                   min = 1, max = max_pitch, value = 1),
      numericInput("pitchRangeMax", "Maximum Pitch Number", 
                   min = 1, max = max_pitch, value = max_pitch),
      
      uiOutput("sessionInfo")
    )
  })
  
  observeEvent(input$selectAllDates, {
    req(input$pitcher)
    pitcher_data <- Endicott2026 %>% filter(Pitcher == input$pitcher)
    pitcher_dates <- sort(unique(pitcher_data$Date))
    updateCheckboxGroupInput(session, "dateFilter", 
                             selected = as.character(pitcher_dates))
  })
  
  observeEvent(input$selectNoDates, {
    updateCheckboxGroupInput(session, "dateFilter", selected = character(0))
  })
  
  output$sessionInfo <- renderUI({
    req(input$pitcher, input$dateFilter)
    
    if (length(input$dateFilter) > 0) {
      selected_dates <- as.Date(input$dateFilter)
      pitcher_session_data <- Endicott2026 %>% 
        filter(Pitcher == input$pitcher, Date %in% selected_dates)
      
      if (nrow(pitcher_session_data) > 0) {
        session_summary <- pitcher_session_data %>%
          group_by(Date) %>%
          summarise(pitches = n(), .groups = 'drop') %>%
          mutate(date_label = format(Date, "%m/%d/%Y"))
        
        total_selected_pitches <- sum(session_summary$pitches)
        
        tagList(
          hr(),
          h5(paste0("Selected Outings: ", nrow(session_summary), 
                    " (", total_selected_pitches, " total pitches)")),
          tags$small(HTML(paste0(session_summary$date_label, ": ", 
                                 session_summary$pitches, " pitches", collapse = "<br>")))
        )
      }
    } else {
      tagList(hr(), h5("No Outings Selected"))
    }
  })
  
  filtered_data <- reactive({
    req(input$pitcher, input$pitchRangeMin, input$pitchRangeMax, input$pitchType)
    
    if(input$pitcher == "") return(NULL)
    
    data <- Endicott2026 %>% filter(Pitcher == input$pitcher)
    
    if (!is.null(input$dateFilter) && length(input$dateFilter) > 0) {
      selected_dates <- as.Date(input$dateFilter)
      data <- data %>% filter(Date %in% selected_dates)
    } else {
      return(NULL)
    }
    
    if (input$pitchType != "All") {
      data <- data %>% filter(PitchType == input$pitchType)
    }
    
    data %>% filter(OverallPitchCount >= input$pitchRangeMin & 
                      OverallPitchCount <= input$pitchRangeMax)
  })
  
  output$pitcher_summary_table <- renderDataTable({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(datatable(data.frame(Message = "No data")))
    
    table <- data %>%
      group_by(Pitch = PitchType) %>%
      summarize(
        Pitches = n(),
        AvgVelo = round(mean(Velocity, na.rm = TRUE), 1),
        MaxVelo = round(max(Velocity, na.rm = TRUE), 1),
        SpinRate = round(mean(TotalSpin, na.rm = TRUE), 0),
        IVB = round(mean(VB_spin, na.rm = TRUE), 1),
        HB = round(mean(HB_trajectory, na.rm = TRUE), 1),
        RelZ = round(mean(ReleaseHeight, na.rm = TRUE), 1),
        RelX = round(mean(ReleaseSide, na.rm = TRUE), 1),
        ArmAngle = round(mean(arm_angle, na.rm = TRUE), 1),
        .groups = 'drop'
      ) %>%
      mutate(Usage = scales::percent(Pitches / sum(Pitches), accuracy = 0.1)) %>%
      dplyr::select(Pitch, Pitches, Usage, AvgVelo, MaxVelo, SpinRate, IVB, HB, RelZ, RelX, ArmAngle)
    
    datatable(table, options = list(dom = 't'))
  })
  
  # ── Pitch movement plot with smooth KDE gradient blobs ───────────────────
  output$pitch_movement_plot <- renderPlotly({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    data <- data %>%
      mutate(
        hover_text = paste0(
          "<b>", PitchType, "</b><br>",
          "HB: ", round(HB_trajectory, 1), " in<br>",
          "IVB: ", round(VB_spin, 1), " in<br>",
          "Velocity: ", round(Velocity, 1), " mph<br>",
          "Spin: ", round(TotalSpin, 0), " rpm"
        )
      )
    
    # Colour palette keyed to pitch types
    pitch_types <- unique(data$PitchType)
    pal         <- scales::hue_pal()(length(pitch_types))
    names(pal)  <- pitch_types
    
    # 8 contour shells: outermost faint -> innermost dense
    n_shells     <- 8
    prob_levels  <- seq(0.95, 0.10, length.out = n_shells)
    alpha_levels <- seq(0.04, 0.22, length.out = n_shells)
    
    # Build KDE contour shapes per pitch type
    kde_polys <- purrr::map_dfr(pitch_types, function(pt) {
      sub <- data %>%
        filter(PitchType == pt,
               !is.na(HB_trajectory), !is.na(VB_spin))
      
      if(nrow(sub) < 5) return(NULL)
      
      kde <- MASS::kde2d(
        sub$HB_trajectory, sub$VB_spin,
        n    = 100,
        lims = c(-30, 30, -30, 30)
      )
      
      kde_df  <- expand.grid(x = kde$x, y = kde$y) %>%
        mutate(z = as.vector(kde$z))
      total_z <- sum(kde_df$z)
      
      purrr::map_dfr(seq_along(prob_levels), function(i) {
        lvl        <- prob_levels[i]
        sorted_z   <- sort(kde_df$z, decreasing = TRUE)
        cum_z      <- cumsum(sorted_z) / total_z
        thresh_idx <- which(cum_z >= (1 - lvl))[1]
        thresh     <- if(!is.na(thresh_idx)) sorted_z[thresh_idx] else 0
        
        cl <- grDevices::contourLines(
          x = kde$x, y = kde$y, z = kde$z, levels = thresh
        )
        if(length(cl) == 0) return(NULL)
        
        purrr::map_dfr(seq_along(cl), function(j) {
          data.frame(
            x         = cl[[j]]$x,
            y         = cl[[j]]$y,
            PitchType = pt,
            shell     = i,
            alpha_val = alpha_levels[i],
            group_id  = paste(pt, i, j, sep = "_")
          )
        })
      })
    })
    
    # Base axes
    p <- ggplot() +
      geom_hline(yintercept = 0, linewidth = 0.8, color = "gray60") +
      geom_vline(xintercept = 0, linewidth = 0.8, color = "gray60")
    
    # Layer KDE shells faint -> dense
    if(!is.null(kde_polys) && nrow(kde_polys) > 0) {
      for(i in seq_len(n_shells)) {
        shell_data <- kde_polys %>% filter(shell == i)
        if(nrow(shell_data) == 0) next
        alph <- unique(shell_data$alpha_val)
        # Loop per pitch type so we can set fill colour manually without aes mapping
        for(pt in unique(shell_data$PitchType)) {
          pt_data <- shell_data %>% filter(PitchType == pt)
          p <- p +
            geom_polygon(
              data  = pt_data,
              aes(x = x, y = y, group = group_id),
              fill  = pal[pt],
              alpha = alph,
              color = NA
            )
        }
      }
    }
    
    p <- p +
      geom_point(
        data = data,
        aes(x = HB_trajectory, y = VB_spin, color = PitchType, text = hover_text),
        size = 2.5, alpha = 0.65
      ) +
      scale_color_manual(values = pal, name = "Pitch Type") +
      labs(
        x        = "Horizontal Movement (HB)",
        y        = "Vertical Movement (IVB)",
        title    = paste(input$pitcher, "- Movement Plot (IVB / HB)"),
        subtitle = "Shaded areas show how consistently the pitcher replicates pitch shape"
      ) +
      xlim(-30, 30) + ylim(-30, 30) +
      theme_bw() +
      theme(
        plot.title       = element_text(size = 16, face = "bold", hjust = 0.5),
        plot.subtitle    = element_text(size = 10, color = "gray40", hjust = 0.5),
        legend.position  = "right",
        legend.title     = element_text(size = 11, face = "bold"),
        legend.text      = element_text(size = 10),
        panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_blank()
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(
          bgcolor     = "white",
          font        = list(size = 12, color = "black"),
          bordercolor = "black"
        )
      )
  })
  
  # Interactive pitch release plot
  output$pitch_release_plot <- renderPlotly({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    data <- data %>%
      mutate(
        hover_text = paste0(
          "<b>", PitchType, "</b><br>",
          "Rel Side: ",   round(ReleaseSide,     2), " ft<br>",
          "Rel Height: ", round(ReleaseHeight,    2), " ft<br>",
          "Extension: ",  round(ReleaseExtension, 1), " ft<br>",
          "Arm Angle: ",  round(arm_angle,         1), "\u00b0"
        )
      )
    
    p <- ggplot(data, aes(x = ReleaseSide, y = ReleaseHeight,
                          color = PitchType, text = hover_text)) +
      geom_hline(yintercept = 5, linewidth = 0.5, color = "gray60") +
      geom_vline(xintercept = 0, linewidth = 0.5, color = "gray60") +
      geom_point(size = 3, alpha = 0.7) +
      labs(x     = "Horizontal Release Point",
           y     = "Vertical Release Point",
           color = "Pitch Type",
           title = paste(input$pitcher, "- Release Points")) +
      xlim(-4, 4) + ylim(2, 7) +
      theme_bw() +
      theme(
        plot.title       = element_text(size = 16, face = "bold", hjust = 0.5),
        legend.position  = "bottom",
        legend.title     = element_text(size = 11, face = "bold"),
        legend.text      = element_text(size = 10),
        panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_blank()
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(
          bgcolor     = "white",
          font        = list(size = 12, color = "black"),
          bordercolor = "black"
        )
      )
  })
  
  output$arm_angle_plot <- renderPlotly({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    arm_data <- data %>% filter(!is.na(arm_angle), !is.na(Height))
    if(nrow(arm_data) == 0) return(NULL)
    
    # Everything in normalized units — shoulder fixed at y = 0
    arm_len <- 1.8
    body_w  <- 0.20
    body_h  <- 0.65
    head_r  <- 0.18
    head_cy <- 0.42   # head center above shoulder
    
    theta <- seq(0, 2 * pi, length.out = 100)
    head_circle <- data.frame(
      x = head_r * cos(theta),
      y = head_cy + head_r * sin(theta)
    )
    
    # One row per pitch type
    avg_angles <- arm_data %>%
      group_by(PitchType) %>%
      summarise(
        avg_angle = mean(arm_angle,   na.rm = TRUE),
        sd_angle  = sd(arm_angle,     na.rm = TRUE),
        avg_side  = mean(ReleaseSide, na.rm = TRUE),
        n         = n(),
        .groups   = 'drop'
      ) %>%
      mutate(
        sd_angle    = ifelse(is.na(sd_angle) | sd_angle == 0, 0.5, sd_angle),
        angle_rad   = avg_angle * pi / 180,
        x_dir       = sign(avg_side),
        xend        = x_dir * cos(angle_rad) * arm_len,
        yend        = sin(angle_rad) * arm_len,
        hover_label = paste0(
          "<b>", PitchType, "</b><br>",
          "Avg Arm Angle: ", round(avg_angle, 1), "\u00b0<br>",
          "SD: \u00b1",      round(sd_angle,  1), "\u00b0<br>",
          "Pitches: ",       n
        )
      )
    
    pitch_types <- unique(avg_angles$PitchType)
    pal         <- scales::hue_pal()(length(pitch_types))
    names(pal)  <- pitch_types
    
    p <- ggplot() +
      geom_rect(aes(xmin = -body_w, xmax = body_w,
                    ymin = -body_h,  ymax = 0),
                fill = "gray80", color = NA, alpha = 0.5) +
      geom_polygon(data = head_circle, aes(x = x, y = y),
                   fill = "gray80", color = NA, alpha = 0.5) +
      geom_point(aes(x = 0, y = 0), color = "gray40", size = 3) +
      geom_segment(
        data      = avg_angles,
        aes(x = 0, y = 0, xend = xend, yend = yend,
            color = PitchType, text = hover_label),
        linewidth = 2.2,
        alpha     = 1,
        arrow     = arrow(length = unit(0.3, "cm"))
      ) +
      scale_color_manual(values = pal, name = "Pitch Type") +
      coord_fixed(ratio = 1) +
      xlim(-2.2, 2.2) +
      ylim(-body_h - 0.15, arm_len * 0.85) +
      labs(
        title    = paste(input$pitcher, "- Arm Angle by Pitch Type"),
        subtitle = "One arrow per pitch type · Origin = shoulder · Hover for details"
      ) +
      theme_minimal() +
      theme(
        plot.title      = element_text(size = 16, face = "bold",    hjust = 0.5),
        plot.subtitle   = element_text(size = 10, color = "gray40", hjust = 0.5),
        axis.text       = element_blank(),
        axis.title      = element_blank(),
        panel.grid      = element_blank(),
        legend.position = "bottom"
      )
    
    ggplotly(p, tooltip = "text") %>%
      layout(
        hoverlabel = list(
          bgcolor     = "white",
          font        = list(size = 14, color = "black"),
          bordercolor = "black"
        )
      )
  })
  
  # ============================================================================
  # PITCH SEQUENCING TAB OUTPUTS
  # ============================================================================
  
  output$sequence_title <- renderText({
    req(input$pitcher)
    paste(input$pitcher, "- Pitch Sequencing Matrix")
  })
  
  # Reactive value to store clicked cell
  clicked_cell <- reactiveValues(first_pitch = NULL, second_pitch = NULL)
  
  output$sequence_matrix <- renderPlot({
    req(input$pitcher)
    
    pitcher_matrix <- pitch_pair_matrix %>%
      filter(Pitcher == input$pitcher)
    
    if(nrow(pitcher_matrix) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, 
                        label = "No pitch sequence data available\n(IsStrike column may be missing)", 
                        size = 6, color = "gray50") +
               theme_void())
    }
    
    # Get all unique pitch types for this pitcher
    all_pitch_types <- sort(unique(c(pitcher_matrix$prev_pitch_type, 
                                     pitcher_matrix$PitchType)))
    
    # Create complete matrix with all combinations
    complete_matrix <- expand.grid(
      prev_pitch_type = all_pitch_types,
      PitchType = all_pitch_types,
      stringsAsFactors = FALSE
    ) %>%
      left_join(pitcher_matrix, by = c("prev_pitch_type", "PitchType")) %>%
      mutate(
        Pitcher = input$pitcher,
        n_pairs = ifelse(is.na(n_pairs), 0, n_pairs),
        avg_strike_rate = ifelse(is.na(avg_strike_rate), NA, avg_strike_rate),
        cell_label = ifelse(n_pairs > 0, 
                            paste0(round(avg_strike_rate * 100, 0), "%\n(n=", n_pairs, ")"),
                            "")
      )
    
    # Create the heatmap
    ggplot(complete_matrix, aes(x = prev_pitch_type, y = PitchType, fill = avg_strike_rate)) +
      geom_tile(color = "white", linewidth = 1.5) +
      geom_text(aes(label = cell_label), size = 4, fontface = "bold", 
                color = "black", lineheight = 0.85) +
      scale_fill_gradient2(
        low = "#d73027", 
        mid = "#ffffbf", 
        high = "#1a9850",
        midpoint = 0.5,
        na.value = "gray90",
        limits = c(0, 1),
        labels = scales::percent_format(),
        name = "Strike Rate"
      ) +
      labs(
        x = "First Pitch",
        y = "Second Pitch",
        title = ""
      ) +
      theme_minimal(base_size = 14) +
      theme(
        axis.text.x = element_text(angle = 0, hjust = 0.5, size = 12, face = "bold"),
        axis.text.y = element_text(size = 12, face = "bold"),
        axis.title = element_text(size = 13, face = "bold"),
        panel.grid = element_blank(),
        legend.position = "right",
        legend.title = element_text(size = 11, face = "bold"),
        legend.text = element_text(size = 10),
        plot.margin = margin(10, 10, 10, 10)
      ) +
      coord_fixed()
  })
  
  # Handle click event on the matrix
  observeEvent(input$matrix_click, {
    req(input$pitcher, input$matrix_click)
    
    pitcher_matrix <- pitch_pair_matrix %>%
      filter(Pitcher == input$pitcher)
    
    all_pitch_types <- sort(unique(c(pitcher_matrix$prev_pitch_type, 
                                     pitcher_matrix$PitchType)))
    
    # Calculate which cell was clicked
    x_index <- round(input$matrix_click$x)
    y_index <- round(input$matrix_click$y)
    
    if(x_index >= 1 && x_index <= length(all_pitch_types) &&
       y_index >= 1 && y_index <= length(all_pitch_types)) {
      
      clicked_cell$first_pitch <- all_pitch_types[x_index]
      clicked_cell$second_pitch <- all_pitch_types[y_index]
    }
  })
  
  output$hover_first_pitch_label <- renderText({
    if(!is.null(clicked_cell$first_pitch)) {
      paste("First Pitch:", clicked_cell$first_pitch)
    } else {
      "First Pitch: (click a cell)"
    }
  })
  
  output$hover_second_pitch_label <- renderText({
    if(!is.null(clicked_cell$second_pitch)) {
      paste("Second Pitch:", clicked_cell$second_pitch)
    } else {
      "Second Pitch: (click a cell)"
    }
  })
  
  output$hover_stats <- renderUI({
    req(clicked_cell$first_pitch, clicked_cell$second_pitch)
    
    pair_data <- pitch_pair_matrix %>%
      filter(
        Pitcher == input$pitcher,
        prev_pitch_type == clicked_cell$first_pitch,
        PitchType == clicked_cell$second_pitch
      )
    
    if(nrow(pair_data) == 0) {
      return(HTML("<p style='text-align: center; color: #999;'>No data for this sequence</p>"))
    }
    
    HTML(paste0(
      "<div style='text-align: left;'>",
      "<p style='margin: 5px 0;'><b>Sequence Count:</b> ", pair_data$n_pairs, " pitches</p>",
      "<p style='margin: 5px 0;'><b>First Pitch Strike Rate:</b> ", 
      round(pair_data$first_strike_rate * 100, 1), "%</p>",
      "<p style='margin: 5px 0;'><b>Second Pitch Strike Rate:</b> ", 
      round(pair_data$second_strike_rate * 100, 1), "%</p>",
      "<p style='margin: 5px 0;'><b>Both Strikes:</b> ", 
      round(pair_data$both_strike_rate * 100, 1), "%</p>",
      "<p style='margin: 5px 0;'><b>Strike Rate Change:</b> ", 
      ifelse(pair_data$strike_rate_diff >= 0, "+", ""),
      round(pair_data$strike_rate_diff * 100, 1), " pp</p>",
      "</div>"
    ))
  })
  
  output$hover_first_pitch_location <- renderPlot({
    req(clicked_cell$first_pitch, input$pitcher)
    
    first_pitch <- clicked_cell$first_pitch
    
    # Get location data for first pitch
    loc_data <- pitch_sequences %>%
      filter(
        Pitcher == input$pitcher,
        prev_pitch_type == first_pitch
      ) %>%
      dplyr::select(prev_plate_loc_side, prev_plate_loc_height) %>%
      filter(!is.na(prev_plate_loc_side), !is.na(prev_plate_loc_height))
    
    if(nrow(loc_data) < 5) {
      return(
        ggplot() +
          annotate("text", x = 0, y = 2.5, label = "Insufficient data", 
                   size = 5, color = "gray50") +
          theme_void()
      )
    }
    
    # Rename columns for consistency with Heat Maps slide code
    loc_data <- loc_data %>%
      rename(PlateLocSide = prev_plate_loc_side,
             PlateLocHeight = prev_plate_loc_height)
    
    tryCatch({
      ggplot(loc_data, aes(x = PlateLocSide, y = PlateLocHeight)) +
        stat_density_2d(aes(fill = ..density..), geom = 'raster', contour = FALSE) +
        scale_fill_gradientn(colours = c("blue", "white", "red")) +
        annotate("rect", xmin = -1, xmax = 1, ymin = 1.6, ymax = 3.4,
                 fill = NA, color = "black", alpha = .1) +
        geom_vline(xintercept = 0, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
        geom_hline(yintercept = 2.5, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
        ylim(1, 4) + xlim(-1.8, 1.8) +
        theme_bw() +
        theme_classic() +
        xlab("") +
        ylab("") +
        ggtitle(paste0(first_pitch), 
                subtitle = paste0("n = ", nrow(loc_data))) +
        guides(fill = FALSE) +
        theme(
          plot.title = element_text(hjust = 0.5, size = 11, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5, color = "gray40", size = 9)
        )
    }, error = function(e) {
      print(paste("Error in first pitch heatmap:", e$message))
      ggplot() +
        annotate("text", x = 0, y = 2.5, label = paste("Error:", e$message), 
                 size = 4, color = "red") +
        theme_void()
    })
  })
  
  output$hover_second_pitch_location <- renderPlot({
    req(clicked_cell$first_pitch, clicked_cell$second_pitch, input$pitcher)
    
    first_pitch <- clicked_cell$first_pitch
    second_pitch <- clicked_cell$second_pitch
    
    # Get location data for second pitch
    loc_data <- pitch_sequences %>%
      filter(
        Pitcher == input$pitcher,
        prev_pitch_type == first_pitch,
        PitchType == second_pitch
      ) %>%
      dplyr::select(PlateLocSide, PlateLocHeight) %>%
      filter(!is.na(PlateLocSide), !is.na(PlateLocHeight))
    
    if(nrow(loc_data) < 5) {
      return(
        ggplot() +
          annotate("text", x = 0, y = 2.5, label = "Insufficient data", 
                   size = 5, color = "gray50") +
          theme_void()
      )
    }
    
    tryCatch({
      ggplot(loc_data, aes(x = PlateLocSide, y = PlateLocHeight)) +
        stat_density_2d(aes(fill = ..density..), geom = 'raster', contour = FALSE) +
        scale_fill_gradientn(colours = c("blue", "white", "red")) +
        annotate("rect", xmin = -1, xmax = 1, ymin = 1.6, ymax = 3.4,
                 fill = NA, color = "black", alpha = .1) +
        geom_vline(xintercept = 0, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
        geom_hline(yintercept = 2.5, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
        ylim(1, 4) + xlim(-1.8, 1.8) +
        theme_bw() +
        theme_classic() +
        xlab("") +
        ylab("") +
        ggtitle(paste0(second_pitch), 
                subtitle = paste0("n = ", nrow(loc_data))) +
        guides(fill = FALSE) +
        theme(
          plot.title = element_text(hjust = 0.5, size = 11, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5, color = "gray40", size = 9)
        )
    }, error = function(e) {
      print(paste("Error in second pitch heatmap:", e$message))
      ggplot() +
        annotate("text", x = 0, y = 2.5, label = paste("Error:", e$message), 
                 size = 4, color = "red") +
        theme_void()
    })
  })
  
  # ============================================================================
  # END PITCH SEQUENCING TAB OUTPUTS
  # ============================================================================
  
  output$pitch_location_plot1 <- renderPlot({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    ggplot(data, aes(x = PlateLocSide, y = PlateLocHeight, color = PitchType)) +
      geom_point(size = 3, alpha = 0.7) +
      annotate("rect", xmin = -1, xmax = 1, ymin = 1.6, ymax = 3.4,
               fill = NA, color = "black", linewidth = 1) +
      geom_vline(xintercept = 0, linewidth = 0.5, color = "gray60", linetype = "dashed") +
      geom_hline(yintercept = 2.5, linewidth = 0.5, color = "gray60", linetype = "dashed") +
      labs(x = "Horizontal Location", 
           y = "Vertical Location", 
           title = paste(input$pitcher, "- Pitch Locations"), 
           subtitle = "From the Pitcher's Perspective") +
      ylim(1, 4) + xlim(-1.8, 1.8) + 
      theme_bw() +
      theme(
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, hjust = 0.5),
        legend.position = "bottom",
        legend.title = element_text(size = 11, face = "bold"),
        legend.text = element_text(size = 10),
        panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_blank()
      )
  })
  
  output$lineplot1 <- renderPlot({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    plot_data <- data %>%
      arrange(Date, No) %>%
      group_by(PitchType) %>%
      mutate(PitchIndex = row_number() - 1) %>%
      ungroup()
    
    summary_data <- plot_data %>%
      group_by(PitchType) %>%
      summarise(
        avg_velo = mean(Velocity, na.rm = TRUE),
        min_velo = min(Velocity, na.rm = TRUE),
        max_velo = max(Velocity, na.rm = TRUE),
        max_index = max(PitchIndex),
        last_velo = last(Velocity),
        .groups = 'drop'
      ) %>%
      mutate(
        label_text = paste0(round(avg_velo, 1), " mph\n(", round(min_velo, 1), "-", round(max_velo, 1), ")")
      )
    
    ggplot(plot_data, aes(x = PitchIndex, y = Velocity, color = PitchType)) +
      geom_line(linewidth = 1.2, alpha = 0.8) +
      geom_point(size = 1.5, alpha = 0.4) +
      geom_text(data = summary_data,
                aes(x = max_index, y = last_velo, 
                    label = label_text, color = PitchType),
                hjust = -0.1, vjust = 0.5, size = 3, 
                fontface = "plain", lineheight = 0.9) +
      scale_x_continuous(expand = expansion(mult = c(0.02, 0.15))) +
      labs(x = "Pitch Count", 
           y = "Pitch Velocity (MPH)", 
           title = "Pitch Velocity Over Time") +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "plain"),
        axis.title = element_text(size = 11),
        axis.text = element_text(size = 10),
        legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        panel.grid.major = element_line(color = "gray92", linewidth = 0.3),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", color = NA),
        plot.background = element_rect(fill = "white", color = NA)
      )
  }, width = 800, height = 400)
  
  output$lineplot2 <- renderPlot({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    plot_data <- data %>%
      arrange(Date, No) %>%
      group_by(PitchType) %>%
      mutate(PitchIndex = row_number() - 1) %>%
      ungroup()
    
    summary_data <- plot_data %>%
      group_by(PitchType) %>%
      summarise(
        avg_spin = mean(TotalSpin, na.rm = TRUE),
        min_spin = min(TotalSpin, na.rm = TRUE),
        max_spin = max(TotalSpin, na.rm = TRUE),
        max_index = max(PitchIndex),
        last_spin = last(TotalSpin),
        .groups = 'drop'
      ) %>%
      mutate(
        label_text = paste0(round(avg_spin, 0), " rpm\n(", round(min_spin, 0), "-", round(max_spin, 0), ")")
      )
    
    ggplot(plot_data, aes(x = PitchIndex, y = TotalSpin, color = PitchType)) +
      geom_line(linewidth = 1.2, alpha = 0.8) +
      geom_point(size = 1.5, alpha = 0.4) +
      geom_text(data = summary_data,
                aes(x = max_index, y = last_spin, 
                    label = label_text, color = PitchType),
                hjust = -0.1, vjust = 0.5, size = 3, 
                fontface = "plain", lineheight = 0.9) +
      scale_x_continuous(expand = expansion(mult = c(0.02, 0.15))) +
      labs(x = "Pitch Count", 
           y = "Spin Rate (RPM)", 
           title = "Spin Rate Over Time") +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "plain"),
        axis.title = element_text(size = 11),
        axis.text = element_text(size = 10),
        legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        panel.grid.major = element_line(color = "gray92", linewidth = 0.3),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", color = NA),
        plot.background = element_rect(fill = "white", color = NA)
      )
  }, width = 800, height = 400)
  
  output$plot1 <- renderPlot({
    data <- filtered_data()
    req(data)
    if(nrow(data) == 0) return(NULL)
    
    ggplot(data, aes(x = PlateLocSide, y = PlateLocHeight)) +
      stat_density_2d(aes(fill = ..density..), geom = 'raster', contour = FALSE) +
      scale_fill_gradientn(colours = c("blue", "white", "red")) +
      annotate("rect", xmin = -1, xmax = 1, ymin = 1.6, ymax = 3.4,
               fill = NA, color = "black", alpha = .1) +
      geom_vline(xintercept = 0, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
      geom_hline(yintercept = 2.5, linewidth = 0.3, color = "black", linetype = "dashed", alpha = 0.5) +
      ylim(1, 4) + xlim(-1.8, 1.8) +
      theme_bw() +
      theme_classic() +
      xlab("Horizontal Pitch Location") +
      ylab("Vertical Pitch Location") +
      ggtitle(paste(input$pitcher, "- Pitch Location Heat Map"), 
              subtitle = "Pitcher's Perspective") +
      facet_wrap(~PitchType, ncol = 3) +
      guides(fill = FALSE)
  }, width = 700, height = 400)
}
shinyApp(ui = ui, server = server)
